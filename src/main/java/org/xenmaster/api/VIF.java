/*
 * VIF.java
 * Copyright (C) 2011,2012 Wannes De Smet
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.xenmaster.api;

import java.util.*;
import org.xenmaster.controller.BadAPICallException;

/**
 * 
 * @created Oct 10, 2011
 * @author double-u
 */
public class VIF extends XenApiEntity {

    @ConstructorArgument
    protected int deviceIndex;
    @ConstructorArgument
    protected String network;
    @ConstructorArgument
    protected String vm;
    @ConstructorArgument
    protected String mac;
    @ConstructorArgument
    protected int mtu;
    @ConstructorArgument
    protected String qosAlgorithmType;
    protected boolean attached, autogeneratedMAC;
    protected int statusCode;
    protected String statusDetail;
    @Fill
    @ConstructorArgument
    protected Map<String, String> runtimeProperties, otherConfig, qosAlgorithmParams;
    protected String metrics;
    protected final static String XEN_MAC_ADDRESS_PREFIX = "00:16:3e";

    public VIF() {
        this.deviceIndex = -1;
    }

    public VIF(String ref, boolean autoFill) {
        super(ref, autoFill);
    }

    public VIF(String ref) {
        super(ref);
    }

    public void plug() throws BadAPICallException {
        dispatch("plug");
    }

    public void unplug() throws BadAPICallException {
        dispatch("unplug");
    }

    public String create(VM vm, Network network) throws BadAPICallException {
        this.vm = vm.getReference();
        if (this.deviceIndex == -1) {
            this.deviceIndex = vm.getNextAvailableVIFIndex();
            if (this.deviceIndex == -1) {
                ArrayList<String> info = new ArrayList<>();
                info.add(vm.getName());
                throw new BadAPICallException("VIF.create", null, "NO_FREE_VIF_SLOT", info);
            }
        }
        this.network = network.getReference();
        if (this.mac == null || this.mac.isEmpty()) {
            this.mac = generateMACAddress();
        }
        if (this.mtu == 0) {
            network.fillOut();
            this.mtu = network.getMTU();
        }

        this.reference = (String) dispatch("create", collectConstructorArgs());
        return this.reference;
    }
    
    public static List<VIF> getAll() throws BadAPICallException {
        return getAllEntities(VIF.class);
    }

    public void destroy() throws BadAPICallException {
        dispatch("destroy");
    }

    public String getMAC() {
        return mac;
    }

    public int getMTU() {
        return mtu;
    }

    public String getVM() {
        return vm;
    }

    public boolean isAttached() {
        return attached;
    }

    public int getDeviceIndex() {
        return deviceIndex;
    }

    public String getMetrics() {
        return metrics;
    }

    public String getNetwork() {
        return network;
    }

    public Map<String, String> getRuntimeProperties() {
        return runtimeProperties;
    }

    public int getStatusCode() {
        return statusCode;
    }

    public String getStatusDetail() {
        return statusDetail;
    }

    public boolean hasAutogeneratedMAC() {
        return autogeneratedMAC;
    }

    public String generateMACAddress() {
        Random random = new Random();
        StringBuilder sb = new StringBuilder();
        sb.append(XEN_MAC_ADDRESS_PREFIX);
        while (sb.length() < 17) {
            if ((sb.length() + 1) % 3 == 0) {
                sb.append(':');
            }
            sb.append(Integer.toHexString(random.nextInt(16)));
        }
        return sb.toString();
    }

    @Override
    protected Map<String, String> interpretation() {
        HashMap<String, String> map = new HashMap<>();
        map.put("deviceIndex", "device");
        map.put("attached", "currently_attached");
        map.put("autogeneratedMAC", "MAC_autogenerated");
        map.put("mac", "MAC");
        map.put("mtu", "MTU");
        return map;
    }
}
